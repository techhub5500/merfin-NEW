/**
 * Sistema de Logging Avan√ßado
 * - Intercepta console.log, console.error, console.warn
 * - Salva em arquivos com auto-limpeza ap√≥s 5 minutos
 * - Modo silencioso (padr√£o) ou debug (mostra no terminal)
 */

const fs = require('fs');
const path = require('path');

class Logger {
  constructor(options = {}) {
    this.logDir = path.join(__dirname, '../../..', 'log');
    this.currentLogFile = null;
    this.writeStream = null;
    this.debugMode = options.debugMode || process.env.DEBUG_MODE === 'true' || false;
    this.cleanupInterval = null;
    this.logFileCreationTime = null;
    
    // Guardar refer√™ncias originais do console
    this.originalConsole = {
      log: console.log.bind(console),
      error: console.error.bind(console),
      warn: console.warn.bind(console),
      info: console.info.bind(console)
    };
    
    this.initialize();
  }

  /**
   * Inicializa o sistema de logging
   */
  initialize() {
    // Criar diret√≥rio de logs se n√£o existir
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
    }

    // Criar novo arquivo de log
    this.createNewLogFile();

    // Interceptar console
    this.interceptConsole();

    // Iniciar sistema de auto-limpeza (verifica a cada 1 minuto)
    this.startCleanupTimer();

    this.log('INFO', 'üìã Sistema de logging inicializado', {
      logDir: this.logDir,
      logFile: this.currentLogFile,
      debugMode: this.debugMode,
      autoCleanup: '5 minutos'
    });
  }

  /**
   * Cria novo arquivo de log com timestamp
   */
  createNewLogFile() {
    const now = new Date();
    const timestamp = this.formatFileTimestamp(now);
    const fileName = `log_${timestamp}.md`;
    this.currentLogFile = path.join(this.logDir, fileName);
    this.logFileCreationTime = now;

    // Fechar stream anterior se existir
    if (this.writeStream) {
      this.writeStream.end();
    }

    // Criar novo stream
    this.writeStream = fs.createWriteStream(this.currentLogFile, { flags: 'a' });

    // Escrever cabe√ßalho
    const header = `<!-- Log file generated by Logger -->\n\n<div style="padding:12px;border-radius:8px;background:#0b1226;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial;">\n  <h2 style="margin:0 0 6px 0">üìã LOG DE EXECU√á√ÉO</h2>\n  <div style="font-size:13px;opacity:0.95">\n    <strong>Data/Hora Cria√ß√£o:</strong> ${now.toLocaleString('pt-BR')}<br/>\n    <strong>Arquivo:</strong> ${fileName}<br/>\n    <strong>Modo Debug:</strong> ${this.debugMode ? 'ATIVADO' : 'DESATIVADO'}<br/>\n    <strong>Auto-limpeza:</strong> 5 minutos ap√≥s cria√ß√£o\n  </div>\n</div>\n\n---\n\n`;
    this.writeStream.write(header);
  }

  /**
   * Formata timestamp para nome de arquivo
   */
  formatFileTimestamp(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    
    return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
  }

  /**
   * Formata timestamp para log entry
   */
  formatLogTimestamp(date) {
    return date.toLocaleString('pt-BR', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      fractionalSecondDigits: 3
    });
  }

  /**
   * Escreve no arquivo de log
   */
  log(level, ...args) {
    const timestamp = this.formatLogTimestamp(new Date());
    
    // Processar argumentos
    // Construir entrada em Markdown: t√≠tulo + bloco de c√≥digo para objetos
    const headerLine = `### ${timestamp} ‚Äî **${level}**`;

    const bodyParts = args.map(arg => {
      if (typeof arg === 'object') {
        try {
          return '```json\n' + JSON.stringify(arg, null, 2) + '\n```';
        } catch (error) {
          return '```\n' + String(arg) + '\n```';
        }
      }
      // Escape backticks inside strings
      const safe = String(arg).replace(/```/g, "` ` `");
      return safe;
    });

    const logEntry = `${headerLine}\n\n${bodyParts.join('\n\n')}\n\n`;

    // Escrever no arquivo
    if (this.writeStream) {
      this.writeStream.write(logEntry);
    }

    // Se modo debug, mostrar no terminal tamb√©m
    if (this.debugMode) {
      const consoleMethod = level === 'ERROR' ? this.originalConsole.error :
                           level === 'WARN' ? this.originalConsole.warn :
                           this.originalConsole.log;
      // Mostrar vers√£o simplificada no terminal
      consoleMethod(`[${level}]`, ...args);
    }
  }

  /**
   * Intercepta m√©todos do console
   */
  interceptConsole() {
    console.log = (...args) => {
      this.log('LOG', ...args);
    };

    console.error = (...args) => {
      this.log('ERROR', ...args);
    };

    console.warn = (...args) => {
      this.log('WARN', ...args);
    };

    console.info = (...args) => {
      this.log('INFO', ...args);
    };
  }

  /**
   * Restaura console original (√∫til para debugging)
   */
  restoreConsole() {
    console.log = this.originalConsole.log;
    console.error = this.originalConsole.error;
    console.warn = this.originalConsole.warn;
    console.info = this.originalConsole.info;
  }

  /**
   * Inicia timer de auto-limpeza
   */
  startCleanupTimer() {
    // Verificar a cada 1 minuto
    this.cleanupInterval = setInterval(() => {
      this.cleanupOldLogs();
    }, 60 * 1000); // 60 segundos

    // Garantir que o timer n√£o impe√ßa o processo de encerrar
    if (this.cleanupInterval.unref) {
      this.cleanupInterval.unref();
    }
  }

  /**
   * Remove arquivos de log com mais de 5 minutos
   */
  cleanupOldLogs() {
    try {
      const files = fs.readdirSync(this.logDir);
      const now = Date.now();
      const fiveMinutesInMs = 5 * 60 * 1000;

      files.forEach(file => {
        if (!file.startsWith('log_') || !file.endsWith('.md')) {
          return;
        }

        const filePath = path.join(this.logDir, file);

        // N√£o deletar o arquivo atual
        if (filePath === this.currentLogFile) {
          return;
        }

        const stats = fs.statSync(filePath);
        const fileAge = now - stats.birthtimeMs;

        if (fileAge > fiveMinutesInMs) {
          fs.unlinkSync(filePath);
          this.log('INFO', `üóëÔ∏è Log antigo deletado: ${file}`, {
            idade: `${Math.round(fileAge / 60000)} minutos`
          });
        }
      });
    } catch (error) {
      this.log('ERROR', '‚ùå Erro ao limpar logs antigos:', error.message);
    }
  }

  /**
   * Encerra o logger gracefully
   */
  shutdown() {
    this.log('INFO', 'üõë Encerrando sistema de logging...');
    
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }

    if (this.writeStream) {
      this.writeStream.end();
    }

    this.restoreConsole();
  }

  /**
   * Alterna modo debug
   */
  toggleDebugMode(enabled) {
    this.debugMode = enabled;
    this.log('INFO', `üîß Modo debug ${enabled ? 'ATIVADO' : 'DESATIVADO'}`);
  }

  /**
   * Retorna informa√ß√µes sobre logs
   */
  getLogInfo() {
    const files = fs.readdirSync(this.logDir);
    const logFiles = files.filter(f => f.startsWith('log_') && f.endsWith('.md'));
    
    return {
      currentLogFile: this.currentLogFile,
      logDir: this.logDir,
      debugMode: this.debugMode,
      totalLogFiles: logFiles.length,
      logFiles: logFiles.map(file => {
        const filePath = path.join(this.logDir, file);
        const stats = fs.statSync(filePath);
        const ageMinutes = Math.round((Date.now() - stats.birthtimeMs) / 60000);
        
        return {
          name: file,
          path: filePath,
          size: `${(stats.size / 1024).toFixed(2)} KB`,
          created: stats.birthtime.toLocaleString('pt-BR'),
          ageMinutes,
          willDeleteIn: Math.max(0, 5 - ageMinutes) + ' min'
        };
      })
    };
  }
}

// Singleton instance
let loggerInstance = null;

/**
 * Inicializa o logger (chamar no in√≠cio da aplica√ß√£o)
 */
function initLogger(options = {}) {
  if (!loggerInstance) {
    loggerInstance = new Logger(options);
  }
  return loggerInstance;
}

/**
 * Obt√©m a inst√¢ncia do logger
 */
function getLogger() {
  if (!loggerInstance) {
    throw new Error('Logger n√£o foi inicializado. Chame initLogger() primeiro.');
  }
  return loggerInstance;
}

/**
 * Encerra o logger
 */
function shutdownLogger() {
  if (loggerInstance) {
    loggerInstance.shutdown();
    loggerInstance = null;
  }
}

module.exports = {
  initLogger,
  getLogger,
  shutdownLogger,
  Logger
};
